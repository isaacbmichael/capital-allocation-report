# -*- coding: utf-8 -*-
"""Capital_Allocation_MonteCarlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14lq-EjQLDi8Y0HFrR7uXwPTeEJnBYHzy
"""

# ==========================================
# Strategic Capital Allocation Monte Carlo
# Executive HTML Report with Rebalance Frequency Comparisons
# ==========================================

# --- Colab installs ---
!pip -q install yfinance jinja2 nest_asyncio playwright
!playwright install --with-deps chromium

# --- Imports ---
import warnings; warnings.filterwarnings("ignore")
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'Liberation Sans'

from datetime import datetime
from jinja2 import Environment, BaseLoader
import io, base64, os, sys
import nest_asyncio
nest_asyncio.apply()

from playwright.async_api import async_playwright

# --- Parameters (you can tune a few realism knobs here) ---
SEED        = 42
SIMS        = 3000
YEARS       = 20
INITIAL     = 100_000
TARGET      = 0.08                     # CFO policy threshold on benchmark yearly return
START       = "2015-01-01"
END         = "2025-01-01"

DAYS_PER_YR = 252
BLOCK_LEN   = 21                       # moving-block length (21–63 are good sensitivity tests)
MIN_ROWS    = 252*3                    # require ~3y of clean overlap per strategy
TC_BPS      = 10                       # transaction cost (bps of traded notional) on rebalances/switches
BANDS       = 0.00                     # e.g., 0.05 to skip small rebalances within ±5%

# Forward-looking annual drifts (edit to your beliefs; conservative on crypto)
FWD_MU_ANNUAL = {
    "VOO": 0.09, "SPY": 0.09, "^GSPC": 0.09,
    "AI_Blend": 0.10,
    "Crypto_Blend": 0.15,
    "BTC-USD": 0.15, "ETH-USD": 0.15, "XRP-USD": 0.10, "SOL-USD": 0.20,
}
# Annual fees (ER/holding cost; crypto includes a conservative custody/spread proxy)
FEES_ANNUAL = {
    "VOO": 0.0003, "SPY": 0.0009, "^GSPC": 0.0,
    "AI_Blend": 0.0020,
    "Crypto_Blend": 0.0100,
    "BTC-USD": 0.0100, "ETH-USD": 0.0100, "XRP-USD": 0.0100, "SOL-USD": 0.0100,
}

# RNGs
rng = np.random.default_rng(SEED)
np.random.seed(SEED)

# --- Step 1: Download & Align Data (business days) ---
tickers = [
    # Crypto
    "BTC-USD","ETH-USD","XRP-USD","SOL-USD",
    # AI/Tech
    "NVDA","MSFT","GOOGL","AAPL","TSLA","META","AMZN","AMD",
    # Benchmarks
    "VOO","SPY","^GSPC"
]
raw = yf.download(tickers, start=START, end=END, auto_adjust=False, progress=False)

if "Adj Close" in raw.columns:
    px = raw["Adj Close"].copy()
else:
    px = raw["Close"].copy()

px = px.sort_index()

# Force Business Day index; crypto trades daily but we line up on business days.
bidx = pd.bdate_range(px.index.min(), px.index.max(), name="Date")
px_b = px.reindex(bidx).ffill()

# Business-day simple returns
returns = px_b.pct_change()
returns = returns.dropna(how="all")  # drop rows where ALL assets are NaN

# --- Sector blends (expanded) ---
ai_names = [t for t in ["NVDA","MSFT","GOOGL","AAPL","TSLA","META","AMZN","AMD"] if t in returns.columns]
crypto_names = [t for t in ["BTC-USD","ETH-USD","XRP-USD","SOL-USD"] if t in returns.columns]
if ai_names:
    returns["AI_Blend"] = returns[ai_names].mean(axis=1)
if crypto_names:
    returns["Crypto_Blend"] = returns[crypto_names].mean(axis=1)

# Pick a benchmark (required for CFO policy)
benchmark = next((b for b in ["VOO","SPY","^GSPC"] if b in returns.columns), None)
assert benchmark is not None, "No benchmark available (VOO/SPY/^GSPC); adjust tickers or dates."

# -------------- Realistic Engine (block bootstrap + forward drift + fees) --------------
def _per_day(mapping, cols, multiplicative=False, default_val=0.0):
    """Map annual values to per-day for each column in `cols`."""
    out = {}
    for c in cols:
        a = float(mapping.get(c, default_val))
        out[c] = ((1 + a)**(1/DAYS_PER_YR) - 1.0) if multiplicative else (a / DAYS_PER_YR)
    return pd.Series(out)

def _prep_subset(ret_df: pd.DataFrame, cols: list):
    """Drop rows with ANY NaNs in `cols`, then build per-day forward drift & fees."""
    sub = ret_df[cols].dropna(how="any")
    if len(sub) < MIN_ROWS:
        raise ValueError(f"Insufficient clean overlap ({len(sub)} rows) for {cols} (min {MIN_ROWS}).")
    # Remove in-sample drift to avoid leakage, then add forward-looking drift later
    resid = sub - sub.mean()
    mu_d  = _per_day(FWD_MU_ANNUAL, cols, multiplicative=True, default_val=0.09)  # default drift 9%
    fee_d = _per_day(FEES_ANNUAL, cols, multiplicative=False, default_val=0.0)
    return resid, mu_d, fee_d

def _mbb_draw_multi(resid_df, total_days, block_len=BLOCK_LEN):
    """
    Moving-block bootstrap across ALL columns simultaneously.
    Preserves cross-asset correlation and some autocorrelation.
    """
    X = resid_df.values
    n, k = X.shape
    if n < block_len:
        raise ValueError("Not enough history for chosen block length.")
    out = np.empty((total_days, k), dtype=np.float64)
    pos = 0
    while pos < total_days:
        start = rng.integers(0, n - block_len + 1)
        take  = min(block_len, total_days - pos)
        out[pos:pos+take] = X[start:start+take, :]
        pos += take
    return out

def _simulate_rebalanced_daily(R_daily, w_target, initial=INITIAL, rebalance_freq=None, bands=BANDS):
    """
    True daily evolution with optional scheduled rebalancing.
    R_daily: (T, k) simple returns (already drift-adjusted and fee-deducted)
    w_target: target weights (k,), sum=1
    """
    vals = (initial * w_target).astype(float)
    T = R_daily.shape[0]
    step = DAYS_PER_YR if not rebalance_freq else DAYS_PER_YR // rebalance_freq

    for t in range(T):
        vals *= (1.0 + R_daily[t])
        # end-of-subperiod rebalance?
        if rebalance_freq and ((t + 1) % step == 0):
            total = vals.sum()
            w_curr = vals / total
            if bands > 0 and np.all(np.abs(w_curr - w_target) <= bands):
                pass  # within tolerance, skip trading
            else:
                desired = total * w_target
                traded  = np.abs(desired - vals).sum()
                tc_frac = (TC_BPS / 1e4) * traded / total
                total  *= (1.0 - tc_frac)
                vals    = total * w_target
    return vals.sum()

def simulate_strategy_paths(ret_df: pd.DataFrame, weights: dict, sims=SIMS, years=YEARS,
                            rebalance_freq=None):
    """
    Robust multi-asset Monte Carlo:
      - multivariate moving-block bootstrap across strategy assets,
      - remove in-sample mean, add forward-looking drift, subtract fees,
      - true rebalancing with transaction costs.
    rebalance_freq: None (buy & hold), or 1/2/4/12 (Annual/Semi/Quarterly/Monthly).
    """
    cols = [c for c in weights.keys() if c in ret_df.columns]
    if len(cols) != len(weights):
        missing = [c for c in weights.keys() if c not in ret_df.columns]
        raise ValueError(f"Missing assets for strategy: {missing}")
    resid_df, mu_d, fee_d = _prep_subset(ret_df, cols)

    w0 = np.array([weights[c] for c in cols], dtype=np.float64)
    if not np.isclose(w0.sum(), 1.0):
        w0 = w0 / w0.sum()

    out = np.empty(sims, dtype=np.float64)
    total_days = years * DAYS_PER_YR
    add = mu_d[cols].values
    sub = fee_d[cols].values

    for s in range(sims):
        # coherent path across all assets
        path = _mbb_draw_multi(resid_df, total_days, block_len=BLOCK_LEN)        # (T, k) de-meaned
        R    = path + add - sub                                                  # add forward drift, subtract fees

        if rebalance_freq is None:
            # Buy & hold: compound each asset for T days, then mix once at the end
            growth = (1.0 + R).prod(axis=0)                                      # length k
            out[s] = INITIAL * float(np.dot(w0, growth))
        else:
            out[s] = _simulate_rebalanced_daily(R, w0, initial=INITIAL,
                                                rebalance_freq=rebalance_freq, bands=BANDS)
    return out

def monte_carlo_cfo_policy(ret_df: pd.DataFrame, bench_col: str, sims=SIMS, years=YEARS, target=TARGET):
    """
    Each year:
      - sample a coherent 252-day block across {benchmark, BTC-USD, AI_Blend} (if available),
      - if benchmark's sampled year > target, hold 50/50 BTC/AI for that year (daily rebalanced within the year),
        else hold benchmark for that year.
    Switching between states pays TC_BPS once per switch.
    """
    have_btc = "BTC-USD" in ret_df.columns
    have_ai  = "AI_Blend" in ret_df.columns
    cols = [bench_col] + (["BTC-USD"] if have_btc else []) + (["AI_Blend"] if have_ai else [])
    if bench_col not in cols:
        raise ValueError("Benchmark not available for CFO policy.")

    resid_df, mu_d, fee_d = _prep_subset(ret_df, cols)
    add = mu_d[cols].values
    sub = fee_d[cols].values

    out = np.empty(sims, dtype=np.float64)
    for s in range(sims):
        V = INITIAL
        holding = "bench"
        # draw one coherent 252*years path and process year-by-year windows
        path = _mbb_draw_multi(resid_df, years * DAYS_PER_YR, block_len=BLOCK_LEN)
        R    = path + add - sub
        start = 0

        for y in range(years):
            seg = R[start:start+DAYS_PER_YR, :]               # (252, m)
            bench_growth = float((1.0 + seg[:, 0]).prod())
            yr_ret = bench_growth - 1.0

            if have_btc and have_ai and (yr_ret > target):
                risky_daily = 0.5*seg[:, cols.index("BTC-USD")] + 0.5*seg[:, cols.index("AI_Blend")]
                growth = float((1.0 + risky_daily).prod())
                if holding != "risky":
                    V *= (1.0 - TC_BPS/1e4)                   # switching cost once
                V *= growth
                holding = "risky"
            else:
                if holding != "bench":
                    V *= (1.0 - TC_BPS/1e4)
                V *= bench_growth
                holding = "bench"
            start += DAYS_PER_YR
        out[s] = V
    return out

# --- Strategies (include only those with available columns) ---
candidate_strategies = {
    "100% BTC": {"BTC-USD": 1.0},
    "100% XRP": {"XRP-USD": 1.0},
    "AI Blend": {"AI_Blend": 1.0},
    "Crypto Blend": {"Crypto_Blend": 1.0},
    "60% Crypto / 40% AI": {"Crypto_Blend": 0.6, "AI_Blend": 0.4},
    "70% Crypto / 30% AI": {"Crypto_Blend": 0.7, "AI_Blend": 0.3},
    f"40% AI / 60% {benchmark}": {"AI_Blend": 0.4, benchmark: 0.6},
    "70% AI / 30% Crypto": {"AI_Blend": 0.7, "Crypto_Blend": 0.3},
    f"100% {benchmark}": {benchmark: 1.0},
}

strategies = {}
for name, w in candidate_strategies.items():
    if all(k in returns.columns for k in w.keys()):
        total_w = sum(v for v in w.values() if v > 0)
        strategies[name] = {k: v/total_w for k, v in w.items() if v > 0}

# --- Run Sims (with safety & logging) ---
sim_results = {}
skipped = []

def _safe_sim(name, func, *args, **kwargs):
    try:
        arr = func(*args, **kwargs)
        if (arr.size == 0) or (not np.isfinite(arr).all()):
            raise ValueError("Non-finite or empty simulation result.")
        sim_results[name] = arr
    except Exception as e:
        skipped.append((name, str(e)))
        print(f"⚠️ Skipped {name}: {e}", file=sys.stderr)

# Baseline: Fixed (buy & hold) + Annual Rebalanced
for n, w in strategies.items():
    _safe_sim(n + " (Fixed)", simulate_strategy_paths, returns, w, rebalance_freq=None)
    _safe_sim(n + " (Rebalanced: Annual)", simulate_strategy_paths, returns, w, rebalance_freq=1)

# Frequency comparisons for the two key mixes
freq_labels = {2: "Semi-Annual", 4: "Quarterly", 12: "Monthly"}
for mix in ["60% Crypto / 40% AI", "70% Crypto / 30% AI"]:
    if mix in strategies:
        w = strategies[mix]
        for f, lbl in freq_labels.items():
            _safe_sim(f"{mix} (Rebalanced: {lbl})", simulate_strategy_paths, returns, w, rebalance_freq=f)

# CFO Policy
_safe_sim("CFO Policy (Target 8%)", monte_carlo_cfo_policy, returns, benchmark)

if skipped:
    print("\n--- Skipped series (data too short or non-finite results) ---")
    for name, msg in skipped:
        print(f"- {name}: {msg}")

# --- Charts ---
# Focused chart for report (cleaner legend)
focus = []
if f"100% {benchmark} (Fixed)" in sim_results:
    focus.append(f"100% {benchmark} (Fixed)")
if "AI Blend (Fixed)" in sim_results:
    focus.append("AI Blend (Fixed)")
if "Crypto Blend (Fixed)" in sim_results:
    focus.append("Crypto Blend (Fixed)")
if "60% Crypto / 40% AI (Rebalanced: Semi-Annual)" in sim_results:
    focus.append("60% Crypto / 40% AI (Rebalanced: Semi-Annual)")
if "70% Crypto / 30% AI (Rebalanced: Semi-Annual)" in sim_results:
    focus.append("70% Crypto / 30% AI (Rebalanced: Semi-Annual)")
if "CFO Policy (Target 8%)" in sim_results:
    focus.append("CFO Policy (Target 8%)")

plt.figure(figsize=(11,6))
for name in focus:
    r = sim_results[name]
    if r.size and np.isfinite(r).all():
        plt.hist(r, bins=120, alpha=0.40, density=True, label=name)
plt.xscale("log")
xmin = min([v.min() for v in sim_results.values()]) * 0.8
xmax = max([v.max() for v in sim_results.values()]) * 1.2
plt.xlim(max(1e3, xmin), xmax)
plt.xlabel("20-Year Ending Portfolio Value ($, log scale)")
plt.ylabel("Probability Density")
plt.title("Monte Carlo Simulated 20-Year Outcomes (Selected Strategies)")
plt.legend(fontsize=8, ncol=2, frameon=False)

buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=160, bbox_inches="tight")
buf.seek(0)
chart_base64 = base64.b64encode(buf.read()).decode("utf-8")
plt.close()

# Full comparison chart artifact (many series → large legend)
plt.figure(figsize=(12,7))
colors = plt.cm.tab20.colors
i = 0
for name, r in sim_results.items():
    if r.size and np.isfinite(r).all():
        plt.hist(r, bins=160, alpha=0.35, density=True, label=name, color=colors[i % len(colors)])
        i += 1
plt.xscale("log")
xmin = min([v.min() for v in sim_results.values()]) * 0.8
xmax = min(1e9, max([v.max() for v in sim_results.values()]) * 1.2)
plt.xlim(max(1e3, xmin), xmax)
plt.xlabel("20-Year Ending Portfolio Value ($, log scale)")
plt.ylabel("Probability Density")
plt.title("Monte Carlo Simulated 20-Year Outcomes (All Strategies)")
if i > 0:
    plt.legend(fontsize=6, ncol=2, frameon=False)
plt.savefig("capital_allocation_distribution.png", dpi=160, bbox_inches="tight")
plt.close()
print("✅ Chart PNG (all strategies) saved.")

# --- Summary Table with richer decision stats ---
def to_cagr(v, years=YEARS, initial=INITIAL):
    return (np.median(v)/initial)**(1/years) - 1

summary = pd.DataFrame({
    n: {
        "Median": np.median(v),
        "5th % (Downside)": np.percentile(v, 5),
        "95th % (Upside)": np.percentile(v, 95),
        "ROI (Median)": (np.median(v)/INITIAL - 1) * 100,
        "CAGR (Median)": to_cagr(v, years=YEARS, initial=INITIAL),
        "Prob(Loss)": (v < INITIAL).mean(),
        "p(> $1M)": (v >= 1_000_000).mean()
    }
    for n, v in sim_results.items()
    if v.size and np.isfinite(v).all()
}).T.sort_values("Median", ascending=False)

summary_fmt = summary.copy()
summary_fmt["Median"] = summary_fmt["Median"].map(lambda v: f"${v:,.0f}")
summary_fmt["5th % (Downside)"] = summary_fmt["5th % (Downside)"].map(lambda v: f"${v:,.0f}")
summary_fmt["95th % (Upside)"] = summary_fmt["95th % (Upside)"].map(lambda v: f"${v:,.0f}")
summary_fmt["ROI (Median)"] = summary_fmt["ROI (Median)"].map(lambda v: f"{v:,.1f}%")
summary_fmt["CAGR (Median)"] = summary_fmt["CAGR (Median)"].map(lambda v: f"{100*v:,.2f}%")
summary_fmt["Prob(Loss)"] = summary_fmt["Prob(Loss)"].map(lambda v: f"{100*v:,.1f}%")
summary_fmt["p(> $1M)"] = summary_fmt["p(> $1M)"].map(lambda v: f"{100*v:,.1f}%")
summary_html = summary_fmt.to_html(classes="", border=0, escape=False)

# Save summary table as CSV
summary.to_csv("capital_allocation_summary.csv")
print("✅ Summary CSV saved.")

# --- Report Content ---
today = datetime.now().strftime("%Y-%m-%d")

methodology_html = f"""
<p>This report simulates <strong>{YEARS}-year</strong> investment outcomes using a
<strong>multivariate moving-block bootstrap</strong> on <strong>business-day returns</strong> from {START} to {END}.
Blocks of length <strong>{BLOCK_LEN}</strong> are resampled <em>across all assets simultaneously</em> to
preserve <em>cross-asset correlation</em> and <em>volatility clustering</em>.</p>

<p>To avoid overstating expected growth, we <em>remove the in-sample mean</em> (“drift leakage”) and then
apply <em>forward-looking annual drifts</em> together with <em>per-asset fees</em>. This yields more realistic
median growth while retaining fat-tailed distributions.</p>

<ul>
  <li><strong>Fixed (Buy &amp; Hold):</strong> Portfolio weights drift naturally; no scheduled rebalancing.</li>
  <li><strong>Rebalanced:</strong> True rebalancing at the stated frequency (Annual, Semi-Annual, Quarterly, Monthly),
      with transaction costs of <em>{TC_BPS} bps</em> applied on traded notional, and tolerance bands of <em>{BANDS:.0%}</em>.</li>
  <li><strong>CFO Policy:</strong> If the benchmark’s simulated annual return exceeds <em>{int(TARGET*100)}%</em>,
      the portfolio shifts to a 50/50 BTC–AI blend for the next year; otherwise it remains in the benchmark.
      Switching incurs transaction costs.</li>
</ul>

<p class="muted"><strong>Note:</strong> Forward-looking drifts, fees, and rebalancing rules are conservative defaults and can
be modified at the top of the notebook. This methodology produces credible long-run medians and realistic
short-run dynamics consistent with observed market behavior.</p>

<p class="muted"><strong>Data:</strong> Historical prices were downloaded from
<a href="https://finance.yahoo.com/" target="_blank">Yahoo Finance</a> using the
<em>yfinance</em> Python package. Individual datasets can also be accessed manually via each ticker’s
Yahoo Finance “Historical Data” page:</p>

<ul>
  <li><a href="https://finance.yahoo.com/quote/BTC-USD/history" target="_blank">BTC-USD – Bitcoin</a></li>
  <li><a href="https://finance.yahoo.com/quote/ETH-USD/history" target="_blank">ETH-USD – Ethereum</a></li>
  <li><a href="https://finance.yahoo.com/quote/XRP-USD/history" target="_blank">XRP-USD – Ripple</a></li>
  <li><a href="https://finance.yahoo.com/quote/SOL-USD/history" target="_blank">SOL-USD – Solana</a></li>
  <li><a href="https://finance.yahoo.com/quote/NVDA/history" target="_blank">NVDA – NVIDIA</a></li>
  <li><a href="https://finance.yahoo.com/quote/MSFT/history" target="_blank">MSFT – Microsoft</a></li>
  <li><a href="https://finance.yahoo.com/quote/GOOGL/history" target="_blank">GOOGL – Alphabet (Google)</a></li>
  <li><a href="https://finance.yahoo.com/quote/AAPL/history" target="_blank">AAPL – Apple</a></li>
  <li><a href="https://finance.yahoo.com/quote/TSLA/history" target="_blank">TSLA – Tesla</a></li>
  <li><a href="https://finance.yahoo.com/quote/META/history" target="_blank">META – Meta Platforms</a></li>
  <li><a href="https://finance.yahoo.com/quote/AMZN/history" target="_blank">AMZN – Amazon</a></li>
  <li><a href="https://finance.yahoo.com/quote/AMD/history" target="_blank">AMD – Advanced Micro Devices</a></li>
  <li><a href="https://finance.yahoo.com/quote/VOO/history" target="_blank">VOO – Vanguard S&P 500 ETF</a></li>
  <li><a href="https://finance.yahoo.com/quote/SPY/history" target="_blank">SPY – SPDR S&P 500 ETF</a></li>
  <li><a href="https://finance.yahoo.com/quote/%5EGSPC/history" target="_blank">^GSPC – S&P 500 Index</a></li>
</ul>

<p class="muted"><strong>Disclaimer:</strong> Educational demonstration only — not financial advice.
Past performance is not indicative of future results.</p>
"""

asset_universe_html = """
<table>
<tr><th>Ticker</th><th>Name / Description</th><th>Category</th></tr>
<tr><td>BTC-USD</td><td>Bitcoin</td><td>Cryptocurrency</td></tr>
<tr><td>ETH-USD</td><td>Ethereum</td><td>Cryptocurrency</td></tr>
<tr><td>XRP-USD</td><td>Ripple (XRP)</td><td>Cryptocurrency</td></tr>
<tr><td>SOL-USD</td><td>Solana</td><td>Cryptocurrency</td></tr>
<tr><td>NVDA</td><td>NVIDIA – AI & Semiconductors</td><td>Equity</td></tr>
<tr><td>MSFT</td><td>Microsoft – Cloud & AI</td><td>Equity</td></tr>
<tr><td>GOOGL</td><td>Alphabet (Google) – AI & Search</td><td>Equity</td></tr>
<tr><td>AAPL</td><td>Apple – Consumer Tech</td><td>Equity</td></tr>
<tr><td>TSLA</td><td>Tesla – EV & Autonomy</td><td>Equity</td></tr>
<tr><td>META</td><td>Meta Platforms – LLMs & Recsys</td><td>Equity</td></tr>
<tr><td>AMZN</td><td>Amazon – AWS AI/ML</td><td>Equity</td></tr>
<tr><td>AMD</td><td>AMD – AI/Accelerators</td><td>Equity</td></tr>
<tr><td>VOO</td><td>Vanguard S&P 500 ETF</td><td>Benchmark</td></tr>
<tr><td>SPY</td><td>SPDR S&P 500 ETF</td><td>Benchmark</td></tr>
<tr><td>^GSPC</td><td>S&P 500 Index</td><td>Benchmark</td></tr>
</table>
"""

strategy_definitions_html = f"""
<ul>
<li><strong>100% BTC:</strong> Entire portfolio allocated to Bitcoin (BTC-USD).</li>
<li><strong>100% XRP:</strong> Entire portfolio allocated to Ripple (XRP-USD).</li>
<li><strong>AI Blend:</strong> Equal-weighted basket of major AI/tech equities (NVDA, MSFT, GOOGL, AAPL, TSLA, META, AMZN, AMD).</li>
<li><strong>Crypto Blend:</strong> Equal-weighted basket of major cryptocurrencies (BTC-USD, ETH-USD, XRP-USD, SOL-USD).</li>
<li><strong>60% Crypto / 40% AI:</strong> 60% Crypto Blend + 40% AI Blend.</li>
<li><strong>70% Crypto / 30% AI:</strong> 70% Crypto Blend + 30% AI Blend.</li>
<li><strong>40% AI / 60% {benchmark}:</strong> 40% AI Blend + 60% {benchmark} (benchmark ETF or index).</li>
<li><strong>70% AI / 30% Crypto:</strong> 70% AI Blend + 30% Crypto Blend.</li>
<li><strong>100% {benchmark}:</strong> Entire portfolio allocated to the benchmark ({benchmark}).</li>
<li><strong>CFO Policy (Target 8%):</strong> Each year, if the benchmark return exceeds {int(TARGET*100)}%, the portfolio shifts to a 50/50 BTC–AI Blend mix; otherwise it remains in the benchmark. Switching incurs transaction costs.</li>
</ul>
"""

# --- HTML Template ---
env = Environment(loader=BaseLoader())
html_template = env.from_string("""
<!doctype html>
<html lang="en"><head>
<meta charset="utf-8"><title>Executive Capital Allocation Report</title>
<style>
 body{font-family:Arial;background:#f6f7fb;color:#2c3e50;margin:0}
 .wrap{max-width:1100px;margin:40px auto;padding:0 24px}
 .card{background:#fff;border-radius:14px;box-shadow:0 6px 22px rgba(0,0,0,.06);padding:24px;margin-bottom:24px}
 h1{margin:8px 0 0} h2{color:#2c3e50}
 table{border-collapse:collapse;width:100%;margin-top:12px}
 th,td{border:1px solid #e6e8ee;padding:10px;text-align:left}
 th{background:#f0f3f7}
 .muted{color:#7f8c8d} .toc a{color:#0b62d6;text-decoration:none}
 @page { size: A4; margin: 16mm 12mm 18mm 12mm; }
 @media print {
   .card { break-inside: avoid-page; page-break-inside: avoid; }
   thead { display: table-header-group; }
   tfoot { display: table-footer-group; }
   tbody tr { break-inside: avoid; page-break-inside: avoid; }
   h2 { break-before: avoid-page; break-after: avoid-page; }
   .page-break { display:block; break-before: page; page-break-before: always; height:0; }
 }
 @media screen { .page-break { display:none; } }
 a:link, a:visited { color: #0b62d6; text-decoration: none; }
 a:hover { text-decoration: underline; }
</style></head><body>
<div class="wrap">

<div class="card" style="text-align:center">
  <h1>Strategic Capital Allocation: 20-Year Outlook</h1>
  <p>Prepared by Isaac B. Michael, PhD</p>
  <p>Date: {{ today }}</p>
  <p><em>Executive-level Monte Carlo risk/return analysis using real market data</em></p>
</div>

<div class="card toc">
  <h2>Table of Contents</h2>
  <ol>
    <li><a href="#exec">Executive Summary</a></li>
    <li><a href="#dist">Distribution of Outcomes</a></li>
    <li><a href="#conclusion">Conclusions & Recommendations</a></li>
    <li><a href="#method">Appendix A – Methodology</a></li>
    <li><a href="#assets">Appendix B – Asset Universe</a></li>
    <li><a href="#strategies">Appendix C – Strategy Definitions</a></li>
  </ol>
</div>

<div id="exec" class="card">
  <h2>Executive Summary</h2>
  <p>This report evaluates multiple AI, Crypto, and blended strategies vs benchmark ({{ benchmark }}).
  We compare <strong>Fixed</strong> (buy-and-hold) with <strong>Annual</strong>, <strong>Semi-Annual</strong>,
  <strong>Quarterly</strong>, and <strong>Monthly</strong> rebalancing.</p>

  <p><em><strong>Note:</strong> All simulations assume an initial investment of ${{ "{:,.0f}".format(INITIAL) }}.</em></p>

  {{ summary_html | safe }}
</div>

<div class="page-break"></div>

<div id="dist" class="card">
  <h2>Distribution of Outcomes</h2>
  <img src="data:image/png;base64,{{ chart_base64 }}" style="width:100%;border-radius:10px"/>
  <p class="muted"><strong>Note:</strong> Logarithmic scale highlights both downside losses and extreme upside tail.</p>
</div>

<div id="conclusion" class="card">
  <h2>Conclusions & Recommendations</h2>
  <p>These simulations highlight clear differences between benchmark exposure, concentrated innovation bets, and dynamic allocation rules:</p>
  <ul>
    <li><strong>VOO (Benchmark):</strong> Provides the most stable compounding (≈8% CAGR) with very low probability of long-term loss. A reliable core allocation.</li>
    <li><strong>AI or Crypto Blends:</strong> Exhibit extreme upside potential but poor median outcomes and high loss probabilities. These behave like “lottery ticket” strategies.</li>
    <li><strong>Rebalancing:</strong> Annual or Semi-Annual rebalancing strikes a better balance than Quarterly or Monthly, which tend to dampen upside more than they reduce risk.</li>
    <li><strong>CFO Policy (Target 8%):</strong> Clearly outperforms on a risk-adjusted basis — delivering the highest median CAGR (~10%), nearly 40% chance of millionaire outcomes, and only moderate loss risk (~7%).</li>
  </ul>
  <p><strong>Recommendation:</strong> For executives balancing growth with discipline, the <em>CFO Policy</em> allocation stands out as the most attractive strategy. A diversified benchmark core with conditional exposure to high-growth assets provides both resilience and meaningful upside.</p>
</div>

<div id="method" class="card">
  <h2>Appendix A – Methodology</h2>
  {{ methodology_html | safe }}
</div>

<div id="assets" class="card">
  <h2>Appendix B – Asset Universe</h2>
  {{ asset_universe_html | safe }}
</div>

<div id="strategies" class="card">
  <h2>Appendix C – Strategy Definitions</h2>
  {{ strategy_definitions_html | safe }}
</div>

<div class="wrap muted" style="margin-bottom:40px; text-align:center; font-size:0.9em">
  © {{ year }} Isaac B. Michael<br>
  <a href="mailto:isaac.b.michael@gmail.com" target="_blank">Email</a> •
  <a href="https://www.linkedin.com/in/isaacbmichael" target="_blank">LinkedIn</a> •
  <a href="https://isaacbmichael.github.io/" target="_blank">GitHub</a>
</div>
</div></body></html>
""")

html = html_template.render(
    today=today, year=datetime.now().year, benchmark=benchmark,
    chart_base64=chart_base64, summary_html=summary_html,
    methodology_html=methodology_html,
    asset_universe_html=asset_universe_html,
    strategy_definitions_html=strategy_definitions_html,
    INITIAL=INITIAL
)

with open("capital_allocation_report.html", "w", encoding="utf-8") as f:
    f.write(html)
print("✅ Executive HTML report written.")

# --- Optional: Save as PDF with Playwright (board-ready PDF) ---
async def html_to_pdf(input_file, output_file):
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True, args=["--no-sandbox"])
        page = await browser.new_page()
        url = "file://" + os.path.abspath(input_file)
        await page.goto(url, wait_until="networkidle")
        await page.pdf(
            path=output_file,
            print_background=True,
            prefer_css_page_size=True,
            margin={"top": "16mm", "right": "12mm", "bottom": "18mm", "left": "12mm"}
        )
        await browser.close()

# Uncomment to produce a PDF artifact:
# pdf_file = "capital_allocation_report.pdf"
# await html_to_pdf("capital_allocation_report.html", pdf_file)
# print("✅ Executive PDF report written.")